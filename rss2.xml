<?xml version="1.0" encoding="utf-8"?>
<rss version="2.0"
  xmlns:atom="http://www.w3.org/2005/Atom"
  xmlns:content="http://purl.org/rss/1.0/modules/content/">
  <channel>
    <title>漂自己的移，让别人都撞墙去吧</title>
    <link>http://www.gagahappy.com/</link>
    
    <image>
      <url>http://www.gagahappy.com/icon.png</url>
      <title>漂自己的移，让别人都撞墙去吧</title>
      <link>http://www.gagahappy.com/</link>
    </image>
    
    <atom:link href="http://www.gagahappy.com/rss2.xml" rel="self" type="application/rss+xml"/>
    
    <description>喜欢熬夜，喜欢畅游互联网，喜欢鼓捣Ubuntu，喜欢玩魔方臭显摆，喜欢小团体集体行动，喜欢餐前DQ，喜欢STARBUCKS，喜欢看着MM穿着凉快的衣服，喜欢YY~</description>
    <pubDate>Mon, 05 Apr 2021 12:45:20 GMT</pubDate>
    <generator>http://hexo.io/</generator>
    
    <item>
      <title>MySQL自增值申请策略</title>
      <link>http://www.gagahappy.com/mysql-auto-increment-strategy/</link>
      <guid>http://www.gagahappy.com/mysql-auto-increment-strategy/</guid>
      <pubDate>Sat, 27 Mar 2021 10:43:33 GMT</pubDate>
      
        
        
          
          
      <description>&lt;h1 id=&quot;自增值申请策略&quot;&gt;&lt;a href=&quot;#自增值申请策略&quot; class=&quot;headerlink&quot;</description>
          
        
      
      
      
      <content:encoded><![CDATA[<h1 id="自增值申请策略"><a href="#自增值申请策略" class="headerlink" title="自增值申请策略"></a>自增值申请策略</h1><ol><li><p>能否先查ID，再查入数据？</p><p>不能，如果每次插入前，都要在主键的索引树上查询要插入的id是否存在，会大大降低插入插入的效率。</p></li><li><p>能否等事务完成后，再释放自增值的锁？</p><p>不能，如果需要等待当前事务完成，其它事务先能获取自增值的锁，就会大大降低并发。</p></li></ol><h2 id="innodb-autoinc-lock-mode"><a href="#innodb-autoinc-lock-mode" class="headerlink" title="innodb_autoinc_lock_mode"></a><code>innodb_autoinc_lock_mode</code></h2><p>MySQL通过参数<code>innodb_autoinc_lock_mode</code>，来设置自值锁的行为，默认值为1</p><ol><li><p>0值 ：等事务完成才释放锁</p></li><li><p>1值 ：</p><ul><li>对于普通的<code>insert into table</code>，申请到自增锁后就释放，不用等插入语句的完成。</li><li>对于批量插入，类似<code>insert ... select</code>，一直持有自增锁，直到事务执行完成。这样也保证了id的连续性。</li></ul></li><li><p>2值：所有插入操作在申请到自增锁后就释放，包括<code>insert ... select </code>这种</p></li></ol>]]></content:encoded>
      
      
      <category domain="http://www.gagahappy.com/categories/database/">数据库</category>
      
      
      <category domain="http://www.gagahappy.com/tags/mysql/">mysql</category>
      
      
    </item>
    
    <item>
      <title>Go 主程序退出时会进行一些额外工作</title>
      <link>http://www.gagahappy.com/go-main-do-something-when-quit/</link>
      <guid>http://www.gagahappy.com/go-main-do-something-when-quit/</guid>
      <pubDate>Fri, 05 Mar 2021 12:28:56 GMT</pubDate>
      
        
        
          
          
      <description>&lt;p&gt;主goroutine先执行完,子goroutine居然还可以运行&lt;/p&gt;
&lt;figure class=&quot;highlight go&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span</description>
          
        
      
      
      
      <content:encoded><![CDATA[<p>主goroutine先执行完,子goroutine居然还可以运行</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    ch := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>)</span><br><span class="line">    log.Println(<span class="string">&quot;===========&quot;</span>)</span><br><span class="line">    <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">        log.Println(<span class="string">&quot;doing in sub goroutine&quot;</span>)</span><br><span class="line">        <span class="comment">// 主程序向通道发送数据，但此时由于 主 gor 行速度慢</span></span><br><span class="line">        <span class="comment">// 程序还没有执行到 fmt.Println(&quot;x in ch is:&quot;, &lt;-ch)，</span></span><br><span class="line">        <span class="comment">// 通道还没有接收数据，所以此时发生 阻塞</span></span><br><span class="line">        ch &lt;- <span class="number">1</span></span><br><span class="line">        log.Println(<span class="string">&quot;done in sub goroutine&quot;</span>) <span class="comment">// 竞争打印，顺序不定</span></span><br><span class="line">    &#125;()</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 模拟执行速度慢</span></span><br><span class="line">    time.Sleep(<span class="number">1</span> * time.Second)</span><br><span class="line"></span><br><span class="line">    log.Println(<span class="string">&quot;doing in main goroutine&quot;</span>)</span><br><span class="line">    <span class="comment">// 1. 执行到这里时发生，由于子 gor 已经在等待向通道发送数据</span></span><br><span class="line">    <span class="comment">//    所以此处的 从通道接收数据的 &lt;-ch 立即执行</span></span><br><span class="line">    <span class="comment">// 2. 子 gor 被唤酲, 立即向通道发送数据</span></span><br><span class="line">    <span class="comment">// 3. &lt;-ch 开始接收数据</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 当从通道中取出数据时，数据是通道中复制的，这需要花费一定的时间</span></span><br><span class="line">    fmt.Println(<span class="string">&quot;x in ch is:&quot;</span>, &lt;-ch)      <span class="comment">// 竞争打印，顺序不定</span></span><br><span class="line">    log.Println(<span class="string">&quot;done in main goroutine&quot;</span>) <span class="comment">// 竞争打印，顺序不定</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>  output：这个比较奇怪,主 先执行完,子居然还可以运行</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 2021/03/04 16:26:35 doing in sub goroutine</span></span><br><span class="line"><span class="comment">// 2021/03/04 16:26:36 doing in main goroutine</span></span><br><span class="line"><span class="comment">// x in ch is: 1</span></span><br><span class="line"><span class="comment">// 2021/03/04 16:26:36 done in main goroutine (主 先执行完)</span></span><br><span class="line"><span class="comment">// 2021/03/04 16:26:36 done in sub goroutine （子居然还可以运行）</span></span><br></pre></td></tr></table></figure><p>关于原因</p><ol><li><p>Stack Overflow上的答案是 在主 gor 的最后一行代码</p><p><code>log.Println(&quot;done in main goroutine&quot;)</code> 执行完成后，main 所在的 goroutine 还有一些在 <code>runtime</code> 时</p><p>需要完成一些扫尾工作，这些扫尾工作会花费非常少的时间，在这段时间里，子 gor 依然可以运行</p><p>所以可以执行 <code>log.Println(&quot;done in sub goroutine&quot;)</code></p></li><li><p>这也说明了 此次 主 gor 运行的比较慢，给子gor 留下了运行完所有代码的时间</p><p>如果主 gor 运行的特别快，即使扫尾工作需要花费一定的时间，但整体速度依然比</p><p>子 gor 快，则 <code>log.Println(&quot;done in sub goroutine&quot;)</code> 不能被执行</p></li></ol>]]></content:encoded>
      
      
      <category domain="http://www.gagahappy.com/categories/development/">程序开发</category>
      
      
      <category domain="http://www.gagahappy.com/tags/golang/">golang</category>
      
      
    </item>
    
    <item>
      <title>MySQL 行锁两阶段</title>
      <link>http://www.gagahappy.com/mysql-recordlock-2phase/</link>
      <guid>http://www.gagahappy.com/mysql-recordlock-2phase/</guid>
      <pubDate>Tue, 16 Feb 2021 11:19:23 GMT</pubDate>
      
        
        
          
          
      <description>&lt;h1 id=&quot;行锁&quot;&gt;&lt;a href=&quot;#行锁&quot; class=&quot;headerlink&quot; title=&quot;行锁&quot;&gt;&lt;/a&gt;行锁&lt;/h1&gt;&lt;p&gt;优点：&lt;/p&gt;
&lt;p&gt;比起表锁，可以支持更大的并发&lt;/p&gt;
&lt;h1 id=&quot;行锁的实现&quot;&gt;&lt;a href=&quot;#行锁的实现&quot;</description>
          
        
      
      
      
      <content:encoded><![CDATA[<h1 id="行锁"><a href="#行锁" class="headerlink" title="行锁"></a>行锁</h1><p>优点：</p><p>比起表锁，可以支持更大的并发</p><h1 id="行锁的实现"><a href="#行锁的实现" class="headerlink" title="行锁的实现"></a>行锁的实现</h1><p>由存储引擎自已实现，每个存储引擎实现的方式都不一样</p><p> MyISAM 引擎不支持行锁</p><h1 id="两阶段锁"><a href="#两阶段锁" class="headerlink" title="两阶段锁"></a>两阶段锁</h1><p>在更新数据时，需要对数据所在行加锁，但更新数据完成后，锁并不会马上释放，而是要等到事务提交才释放</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">create table t_07_recordlock(</span><br><span class="line">    id int not null auto_increment primary key,</span><br><span class="line">  c int,</span><br><span class="line">  d int,</span><br><span class="line">     key c (c) </span><br><span class="line">) engine&#x3D;innodb;</span><br><span class="line"></span><br><span class="line">insert into t_07_recordlock values (1,1,1),(2,2,2),(3,3,3),(4,4,4),(5,5,5);</span><br></pre></td></tr></table></figure><table><thead><tr><th></th><th>Session A</th><th>Session B</th></tr></thead><tbody><tr><td>T1</td><td>Begin;</td><td>begin;</td></tr><tr><td>T2</td><td>update t_07_recordlock set d=d+1 where id = 1;</td><td></td></tr><tr><td></td><td>update t_07_recordlock set d=d+1 where id = 2;</td><td></td></tr><tr><td>T3</td><td></td><td>update t_07_recordlock set d=d+1 where id = 1;</td></tr><tr><td>T4</td><td>Commit</td><td></td></tr></tbody></table><ul><li>T2时刻，SessionA已经完成了对两行数据的更新，但没有提交</li><li>T3时候，SessionB对id=1的行进行更新，由于Session A没有提交，其依然持有id=1上的写锁，与Session B要加的写锁互斥，所以SessionB被阻塞，直到Session A提交，释放锁，才能对执行更新语句</li></ul>]]></content:encoded>
      
      
      <category domain="http://www.gagahappy.com/categories/database/">数据库</category>
      
      
      <category domain="http://www.gagahappy.com/tags/mysql/">mysql</category>
      
      
    </item>
    
    <item>
      <title>MySQL自增值不能回退</title>
      <link>http://www.gagahappy.com/mysql-auto-increment/</link>
      <guid>http://www.gagahappy.com/mysql-auto-increment/</guid>
      <pubDate>Tue, 12 Jan 2021 12:11:32 GMT</pubDate>
      
        
        
          
          
      <description>&lt;p&gt;MySql</description>
          
        
      
      
      
      <content:encoded><![CDATA[<p>MySql 主键不连续的原因之一是自增值不能回退</p><p>设当前自增值=2，此时并发两个事务T1,T2。T1先申请到自增值，插入ID=3，自增值更为4</p><table><thead><tr><th></th><th>Tx1</th><th>Tx2</th></tr></thead><tbody><tr><td>T1</td><td>申请到自增值=2，set id =2, 更新自增值=3</td><td></td></tr><tr><td>T2</td><td>插入数据失败</td><td>申请到自增值=3，set id=3，更新自增值=4</td></tr><tr><td>T3</td><td>如果让自增值回退到=2</td><td>插入数据成功</td></tr><tr><td>T4</td><td>申请到自增值=2，set id =2, 更新自增值=3</td><td></td></tr><tr><td>T5</td><td>插入数据成功</td><td>申请到自增值=3，set id=3，更新自增值=4</td></tr><tr><td>T6</td><td></td><td>插入数据失败，插入语句报错“主键冲突” id=3已经存在</td></tr></tbody></table>]]></content:encoded>
      
      
      <category domain="http://www.gagahappy.com/categories/database/">数据库</category>
      
      
      <category domain="http://www.gagahappy.com/tags/mysql/">mysql</category>
      
      
    </item>
    
    <item>
      <title>无缓冲通道的Cap是零</title>
      <link>http://www.gagahappy.com/unbuffered-channel-no-cap/</link>
      <guid>http://www.gagahappy.com/unbuffered-channel-no-cap/</guid>
      <pubDate>Tue, 05 Jan 2021 11:59:39 GMT</pubDate>
      
        
        
          
          
      <description>&lt;p&gt;无缓冲通道的cap是零&lt;/p&gt;
&lt;figure class=&quot;highlight go&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span</description>
          
        
      
      
      
      <content:encoded><![CDATA[<p>无缓冲通道的cap是零</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;fmt&quot;</span></span><br><span class="line">    <span class="string">&quot;time&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 无缓冲通道的cap、len永远是0</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    noCache := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123; noCache &lt;- <span class="number">6</span> &#125;()</span><br><span class="line"></span><br><span class="line">    time.Sleep(<span class="number">2</span> * time.Second)</span><br><span class="line">    fmt.Println(<span class="string">&quot;cap of noCache pipeline is&quot;</span>, <span class="built_in">cap</span>(noCache)) <span class="comment">// =&gt; 0</span></span><br><span class="line">    fmt.Println(<span class="string">&quot;len of noCache pipeline is&quot;</span>, <span class="built_in">len</span>(noCache)) <span class="comment">// =&gt; 0</span></span><br><span class="line"></span><br><span class="line">    fmt.Println(<span class="string">&quot;noCache &quot;</span>, &lt;-noCache)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content:encoded>
      
      
      <category domain="http://www.gagahappy.com/categories/development/">程序开发</category>
      
      
      <category domain="http://www.gagahappy.com/tags/golang/">golang</category>
      
      
    </item>
    
  </channel>
</rss>
