<?xml version="1.0" encoding="utf-8"?>
<rss version="2.0"
  xmlns:atom="http://www.w3.org/2005/Atom"
  xmlns:content="http://purl.org/rss/1.0/modules/content/">
  <channel>
    <title>漂自己的移，让别人都撞墙去吧</title>
    <link>http://www.gagahappy.com/</link>
    
    <image>
      <url>http://www.gagahappy.com/icon.png</url>
      <title>漂自己的移，让别人都撞墙去吧</title>
      <link>http://www.gagahappy.com/</link>
    </image>
    
    <atom:link href="http://www.gagahappy.com/rss2.xml" rel="self" type="application/rss+xml"/>
    
    <description>喜欢熬夜，喜欢畅游互联网，喜欢鼓捣Ubuntu，喜欢玩魔方臭显摆，喜欢小团体集体行动，喜欢餐前DQ，喜欢STARBUCKS，喜欢看着MM穿着凉快的衣服，喜欢YY~</description>
    <pubDate>Wed, 14 Apr 2021 11:50:02 GMT</pubDate>
    <generator>http://hexo.io/</generator>
    
    <item>
      <title>sync.Wait的使用</title>
      <link>http://www.gagahappy.com/go-sync-wait/</link>
      <guid>http://www.gagahappy.com/go-sync-wait/</guid>
      <pubDate>Wed, 14 Apr 2021 10:43:00 GMT</pubDate>
      
        
        
          
          
      <description>&lt;p&gt;如何让主 goroutine 在所有其他 goroutine 都运行完后，再退出&lt;/p&gt;
&lt;h1 id=&quot;sleep&quot;&gt;&lt;a href=&quot;#sleep&quot; class=&quot;headerlink&quot; title=&quot;sleep&quot;&gt;&lt;/a&gt;sleep&lt;/h1&gt;&lt;p&gt;通过 sleep</description>
          
        
      
      
      
      <content:encoded><![CDATA[<p>如何让主 goroutine 在所有其他 goroutine 都运行完后，再退出</p><h1 id="sleep"><a href="#sleep" class="headerlink" title="sleep"></a>sleep</h1><p>通过 sleep 让主 goroutine 在所有子goroutine运行结束后，再退出</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">usingSleep</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">10</span>; i++ &#123;</span><br><span class="line"><span class="keyword">go</span> fmt.Println(i)</span><br><span class="line">&#125;</span><br><span class="line">time.Sleep(time.Second)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>缺点：无法判断 for 循环到底需要多长时间，导致估计sleep的时间要么不够，要么太长</p><h1 id="缓冲通道"><a href="#缓冲通道" class="headerlink" title="缓冲通道"></a>缓冲通道</h1><p>通过缓冲通道让主 goroutine 在所有子goroutine运行结束后，再退出</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">usingChannel</span><span class="params">()</span></span> &#123;</span><br><span class="line">c := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;, <span class="number">10</span>)</span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">10</span>; i++ &#123;</span><br><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">(i <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">fmt.Println(i)</span><br><span class="line">c &lt;- <span class="keyword">struct</span>&#123;&#125;&#123;&#125;</span><br><span class="line">&#125;(i)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">10</span>; i++ &#123;</span><br><span class="line">&lt;-c</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>缺点：</p><ul><li>channel应该被用在goroutine间的通信</li><li>如果子goroutine太多，使用通道也会消耗很多资源</li></ul><h1 id="sync-WaitGroup"><a href="#sync-WaitGroup" class="headerlink" title="sync.WaitGroup"></a>sync.WaitGroup</h1><p>使用 sync.WaitGroup()控制主 goroutine 在所有子goroutine运行结束后，再退出</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">waitGroup</span><span class="params">()</span></span> &#123;</span><br><span class="line">wg := sync.WaitGroup&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">10</span>; i++ &#123;</span><br><span class="line">wg.Add(<span class="number">1</span>)</span><br><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">(i <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line"><span class="keyword">defer</span> wg.Done()</span><br><span class="line">fmt.Println(i)</span><br><span class="line">&#125;(i)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">wg.Wait() <span class="comment">// 一直阻塞主goroutine，直到wg为零</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// output</span></span><br><span class="line"><span class="comment">// 乱序输出,并不是按1,2,3,4...</span></span><br><span class="line"><span class="comment">// 2</span></span><br><span class="line"><span class="comment">// 4</span></span><br><span class="line"><span class="comment">// 7</span></span><br><span class="line"><span class="comment">// 3</span></span><br><span class="line"><span class="comment">// 1</span></span><br><span class="line"><span class="comment">// 0</span></span><br><span class="line"><span class="comment">// 9</span></span><br><span class="line"><span class="comment">// 5</span></span><br><span class="line"><span class="comment">// 8</span></span><br><span class="line"><span class="comment">// 6</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p>Wait() 方法的功能是，阻塞当前的 goroutine，直到其所属值中的计数器归零</p></li><li><p>不要把增加其计数器值的操作和调用其Wait方法的代码，放在不同的 goroutine 中执行，如果同时启用的两个 goroutine ，分别调用这两个方法(add 和 wait)，那么就有可能会让这里的Add方法抛出一个 panic。最好用“先统一Add，再并发Done，最后Wait”这种标准方式，来使用WaitGroup值</p></li><li><p>计数器不能为负值，发生为负的情况是：不适当地调用Done方法和Add方法都会如此。</p></li><li><p>Done()是Add(-1)的别名</p></li><li><p>计数不为0, 阻塞Wait()的运行</p></li></ul><h1 id="WaitGroup对象不是一个引用类型"><a href="#WaitGroup对象不是一个引用类型" class="headerlink" title="WaitGroup对象不是一个引用类型"></a>WaitGroup对象不是一个引用类型</h1><p>在通过函数传值的时候需要使用地址，不然会出现 <code>fatal error: all goroutines are asleep - deadlock!</code></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">passWGByPointer</span><span class="params">()</span></span> &#123;</span><br><span class="line">wg := sync.WaitGroup&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">10</span>; i++ &#123;</span><br><span class="line">wg.Add(<span class="number">1</span>)</span><br><span class="line"><span class="keyword">go</span> wgDone(i, &amp;wg)</span><br><span class="line">&#125;</span><br><span class="line">wg.Wait()</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">wgDone</span><span class="params">(i <span class="keyword">int</span>, wg *sync.WaitGroup)</span></span> &#123;</span><br><span class="line"><span class="keyword">defer</span> wg.Done()</span><br><span class="line">fmt.Println(i)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content:encoded>
      
      
      <category domain="http://www.gagahappy.com/categories/development/">程序开发</category>
      
      
      <category domain="http://www.gagahappy.com/tags/golang/">golang</category>
      
      
    </item>
    
    <item>
      <title>Git 使用 Rebase 代替 Merge</title>
      <link>http://www.gagahappy.com/using-rebase-instead-of-merge/</link>
      <guid>http://www.gagahappy.com/using-rebase-instead-of-merge/</guid>
      <pubDate>Tue, 06 Apr 2021 08:11:18 GMT</pubDate>
      
        
        
          
          
      <description>&lt;h1 id=&quot;合并还是变基&quot;&gt;&lt;a href=&quot;#合并还是变基&quot; class=&quot;headerlink&quot;</description>
          
        
      
      
      
      <content:encoded><![CDATA[<h1 id="合并还是变基"><a href="#合并还是变基" class="headerlink" title="合并还是变基"></a>合并还是变基</h1><p>合并分支时，应使用<code>rebase</code>合并分支而不是使用<code>merge</code></p><h2 id="merge"><a href="#merge" class="headerlink" title="merge"></a>merge</h2><p>在分支很多的时候，<code>merge</code>会使提交变得异常混乱，查找某个提交会非常不好找，即使使用图形工具，也无法快速的查找，如果想退到某次提交更是难上加难。<code>merge</code>即使删除了合并过来的分支，其合并轨迹也依然被保留，所以还是很乱。</p><p><img src="http://img.gagahappy.cn/blog/2021/04/using-rebase-instead-of-merge-merge.png_b1" alt="git merge" title="git merge"></p><h2 id="rebase"><a href="#rebase" class="headerlink" title="rebase"></a>rebase</h2><p>在分支很多的时候，不会产生很多的分支线，实践中应该就只有<code>master</code>,<code>release</code>等分支线，功能分支线在合并到<code>master</code> 上后都被删除，这样提交基本都在一条线上，十分清楚整洁。</p><p><img src="http://img.gagahappy.cn/blog/2021/04/using-rebase-instead-of-merge-rebase.png_b1" alt="git rebase" title="git rebase"></p><h1 id="使用rebase合并分支"><a href="#使用rebase合并分支" class="headerlink" title="使用rebase合并分支"></a>使用rebase合并分支</h1><h2 id="场景分析："><a href="#场景分析：" class="headerlink" title="场景分析："></a>场景分析：</h2><p>功能<code>feature1</code>与<code>feature2</code>都在开发，<code>feature1</code>先上线，合并到了master，此时，<code>feature2</code>不应使用<code>merge</code>对<code>master</code>进行合并操作，而是使用<code>rebase</code>进行合并</p><ul><li><p>master上的提交有：<code>[m1, m2, m3]</code></p></li><li><p>feature1上的提交有: <code>[f1_01, f1_02, f1_03]</code> </p></li><li><p>feature2上的提交有: <code>[f2_01, f2_02, f2_03]</code> </p></li></ul><p><code>feature1</code>先被合并到master: </p><ul><li>master上的提交有：<code>[m1, m2, m3, f1_01, f1_02, f1_03]</code></li></ul><p><code>feature2</code>合并master</p><ul><li><code>feature2</code>上的提交有：<code>[m1, m2, m3, f1_01, f1_02, f1_03，f2_01_new, f2_02_new, f2_03_new]</code></li></ul><h2 id="合并步骤"><a href="#合并步骤" class="headerlink" title="合并步骤"></a>合并步骤</h2><p><code>feature2</code>要把<code>master</code>上的提交合并过来，使用<code>rebase</code> 而不是<code>merge</code>，这样就会不产生合并提交，在向<code>master</code>提交时就变成了<code>快速向前</code></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">git co feature2</span><br><span class="line">git rebase master</span><br><span class="line"></span><br><span class="line"><span class="comment"># 如果发生冲突，解决冲突后把冲突文件加入 index 区</span></span><br><span class="line">git add -u </span><br><span class="line"><span class="comment"># 运行continue 以使rebase完成</span></span><br><span class="line">git rebase --<span class="built_in">continue</span></span><br></pre></td></tr></table></figure><ul><li><p>步骤1：<code>git rebase master</code>：以<code>master</code>分支做为<code>feature2</code>的基础</p></li><li><p>步骤2：计算出<code>feature2</code>与<code>master</code>上的差异提交，相当于<code>git log master...feture2</code>，即<code>[f2_01, f2_02, f2_03]</code> </p></li><li><p>步骤3：把<code>[f2_01, f2_02, f2_03]</code>在<code>master</code>上的最新提交<code>f1_03</code>上进行重放生成新的提交</p><p><code>[f2_01_new, f2_02_new, f2_03_new]</code></p><p>重放生成过程：</p><ol><li>f2_01以f1_03为基础，生成新的f2_01_new</li><li>f2_02以f2_01_new为基础，生成新的f2_02_new</li><li>f2_03以f2_02_new为基础，生成新的f2_03_new</li></ol></li><li><p>步骤4：把当前分支设置为<code>feature2</code></p><p>feature2<code>rebase</code>后的提交有<code>[m1, m2, m3, f1_01, f1_02, f1_03，f2_01_new, f2_02_new, f2_03_new]</code></p><p>之前的旧的<code>[f2_01, f2_02, f2_03]</code> 在<code>feature2</code>上就看不到了，但依然在git中，如果没有其它分支指向它们，则会被git 回收机制删除</p></li></ul><h1 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h1><ol><li>merge会让提交变得越来越混乱</li><li>rebase可以使主线一直保持清晰，rebase操作可以看是剪支操作，把分支剪下来，接到主线上。这样就可以把多条分支线变为一条，使所有提交变得清晰。</li><li>不要对已经<code>push</code>了的分支进行<code>rebase</code>，这会让已经存在的提交丢失，如果有人已经拉取了这个分支，也会给别人提交带来混乱</li></ol>]]></content:encoded>
      
      
      <category domain="http://www.gagahappy.com/categories/development/">程序开发</category>
      
      
      <category domain="http://www.gagahappy.com/tags/git/">git</category>
      
      
    </item>
    
    <item>
      <title>MySQL自增值申请策略</title>
      <link>http://www.gagahappy.com/mysql-auto-increment-strategy/</link>
      <guid>http://www.gagahappy.com/mysql-auto-increment-strategy/</guid>
      <pubDate>Sat, 27 Mar 2021 10:43:33 GMT</pubDate>
      
        
        
          
          
      <description>&lt;h1 id=&quot;自增值申请策略&quot;&gt;&lt;a href=&quot;#自增值申请策略&quot; class=&quot;headerlink&quot;</description>
          
        
      
      
      
      <content:encoded><![CDATA[<h1 id="自增值申请策略"><a href="#自增值申请策略" class="headerlink" title="自增值申请策略"></a>自增值申请策略</h1><ol><li><p>能否先查ID，再查入数据？</p><p>不能，如果每次插入前，都要在主键的索引树上查询要插入的id是否存在，会大大降低插入插入的效率。</p></li><li><p>能否等事务完成后，再释放自增值的锁？</p><p>不能，如果需要等待当前事务完成，其它事务先能获取自增值的锁，就会大大降低并发。</p></li></ol><h2 id="innodb-autoinc-lock-mode"><a href="#innodb-autoinc-lock-mode" class="headerlink" title="innodb_autoinc_lock_mode"></a><code>innodb_autoinc_lock_mode</code></h2><p>MySQL通过参数<code>innodb_autoinc_lock_mode</code>，来设置自值锁的行为，默认值为1</p><ol><li><p>0值 ：等事务完成才释放锁</p></li><li><p>1值 ：</p><ul><li>对于普通的<code>insert into table</code>，申请到自增锁后就释放，不用等插入语句的完成。</li><li>对于批量插入，类似<code>insert ... select</code>，一直持有自增锁，直到事务执行完成。这样也保证了id的连续性。</li></ul></li><li><p>2值：所有插入操作在申请到自增锁后就释放，包括<code>insert ... select </code>这种</p></li></ol>]]></content:encoded>
      
      
      <category domain="http://www.gagahappy.com/categories/database/">数据库</category>
      
      
      <category domain="http://www.gagahappy.com/tags/mysql/">mysql</category>
      
      
    </item>
    
    <item>
      <title>Go 主程序退出时会进行一些额外工作</title>
      <link>http://www.gagahappy.com/go-main-do-something-when-quit/</link>
      <guid>http://www.gagahappy.com/go-main-do-something-when-quit/</guid>
      <pubDate>Fri, 05 Mar 2021 12:28:56 GMT</pubDate>
      
        
        
          
          
      <description>&lt;p&gt;主goroutine先执行完,子goroutine居然还可以运行&lt;/p&gt;
&lt;figure class=&quot;highlight go&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span</description>
          
        
      
      
      
      <content:encoded><![CDATA[<p>主goroutine先执行完,子goroutine居然还可以运行</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">ch := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>)</span><br><span class="line">log.Println(<span class="string">&quot;===========&quot;</span>)</span><br><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">log.Println(<span class="string">&quot;doing in sub goroutine&quot;</span>)</span><br><span class="line"><span class="comment">// 主程序向通道发送数据，但此时由于 主 gor 行速度慢</span></span><br><span class="line"><span class="comment">// 程序还没有执行到 fmt.Println(&quot;x in ch is:&quot;, &lt;-ch)，</span></span><br><span class="line"><span class="comment">// 通道还没有接收数据，所以此时发生 阻塞</span></span><br><span class="line">ch &lt;- <span class="number">1</span></span><br><span class="line">log.Println(<span class="string">&quot;done in sub goroutine&quot;</span>) <span class="comment">// 竞争打印，顺序不定</span></span><br><span class="line">&#125;()</span><br><span class="line"></span><br><span class="line"><span class="comment">// 模拟执行速度慢</span></span><br><span class="line">time.Sleep(<span class="number">1</span> * time.Second)</span><br><span class="line"></span><br><span class="line">log.Println(<span class="string">&quot;doing in main goroutine&quot;</span>)</span><br><span class="line"><span class="comment">// 1. 执行到这里时发生，由于子 gor 已经在等待向通道发送数据</span></span><br><span class="line"><span class="comment">//    所以此处的 从通道接收数据的 &lt;-ch 立即执行</span></span><br><span class="line"><span class="comment">// 2. 子 gor 被唤酲, 立即向通道发送数据</span></span><br><span class="line"><span class="comment">// 3. &lt;-ch 开始接收数据</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 当从通道中取出数据时，数据是通道中复制的，这需要花费一定的时间</span></span><br><span class="line">fmt.Println(<span class="string">&quot;x in ch is:&quot;</span>, &lt;-ch)      <span class="comment">// 竞争打印，顺序不定</span></span><br><span class="line">log.Println(<span class="string">&quot;done in main goroutine&quot;</span>) <span class="comment">// 竞争打印，顺序不定</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>  output：这个比较奇怪,主 先执行完,子居然还可以运行</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 2021/03/04 16:26:35 doing in sub goroutine</span></span><br><span class="line"><span class="comment">// 2021/03/04 16:26:36 doing in main goroutine</span></span><br><span class="line"><span class="comment">// x in ch is: 1</span></span><br><span class="line"><span class="comment">// 2021/03/04 16:26:36 done in main goroutine (主 先执行完)</span></span><br><span class="line"><span class="comment">// 2021/03/04 16:26:36 done in sub goroutine （子居然还可以运行）</span></span><br></pre></td></tr></table></figure><p>关于原因</p><ol><li><p>Stack Overflow上的答案是 在主 gor 的最后一行代码</p><p><code>log.Println(&quot;done in main goroutine&quot;)</code> 执行完成后，main 所在的 goroutine 还有一些在 <code>runtime</code> 时</p><p>需要完成一些扫尾工作，这些扫尾工作会花费非常少的时间，在这段时间里，子 gor 依然可以运行</p><p>所以可以执行 <code>log.Println(&quot;done in sub goroutine&quot;)</code></p></li><li><p>这也说明了 此次 主 gor 运行的比较慢，给子gor 留下了运行完所有代码的时间</p><p>如果主 gor 运行的特别快，即使扫尾工作需要花费一定的时间，但整体速度依然比</p><p>子 gor 快，则 <code>log.Println(&quot;done in sub goroutine&quot;)</code> 不能被执行</p></li></ol>]]></content:encoded>
      
      
      <category domain="http://www.gagahappy.com/categories/development/">程序开发</category>
      
      
      <category domain="http://www.gagahappy.com/tags/golang/">golang</category>
      
      
    </item>
    
    <item>
      <title>MySQL 行锁两阶段</title>
      <link>http://www.gagahappy.com/mysql-recordlock-2phase/</link>
      <guid>http://www.gagahappy.com/mysql-recordlock-2phase/</guid>
      <pubDate>Tue, 16 Feb 2021 11:19:23 GMT</pubDate>
      
        
        
          
          
      <description>&lt;h1 id=&quot;行锁&quot;&gt;&lt;a href=&quot;#行锁&quot; class=&quot;headerlink&quot; title=&quot;行锁&quot;&gt;&lt;/a&gt;行锁&lt;/h1&gt;&lt;p&gt;优点：&lt;/p&gt;
&lt;p&gt;比起表锁，可以支持更大的并发&lt;/p&gt;
&lt;h1 id=&quot;行锁的实现&quot;&gt;&lt;a href=&quot;#行锁的实现&quot;</description>
          
        
      
      
      
      <content:encoded><![CDATA[<h1 id="行锁"><a href="#行锁" class="headerlink" title="行锁"></a>行锁</h1><p>优点：</p><p>比起表锁，可以支持更大的并发</p><h1 id="行锁的实现"><a href="#行锁的实现" class="headerlink" title="行锁的实现"></a>行锁的实现</h1><p>由存储引擎自已实现，每个存储引擎实现的方式都不一样</p><p> MyISAM 引擎不支持行锁</p><h1 id="两阶段锁"><a href="#两阶段锁" class="headerlink" title="两阶段锁"></a>两阶段锁</h1><p>在更新数据时，需要对数据所在行加锁，但更新数据完成后，锁并不会马上释放，而是要等到事务提交才释放</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">create table t_07_recordlock(</span><br><span class="line">id int not null auto_increment primary key,</span><br><span class="line">  c int,</span><br><span class="line">  d int,</span><br><span class="line"> key c (c) </span><br><span class="line">) engine&#x3D;innodb;</span><br><span class="line"></span><br><span class="line">insert into t_07_recordlock values (1,1,1),(2,2,2),(3,3,3),(4,4,4),(5,5,5);</span><br></pre></td></tr></table></figure><table><thead><tr><th></th><th>Session A</th><th>Session B</th></tr></thead><tbody><tr><td>T1</td><td>Begin;</td><td>begin;</td></tr><tr><td>T2</td><td>update t_07_recordlock set d=d+1 where id = 1;</td><td></td></tr><tr><td></td><td>update t_07_recordlock set d=d+1 where id = 2;</td><td></td></tr><tr><td>T3</td><td></td><td>update t_07_recordlock set d=d+1 where id = 1;</td></tr><tr><td>T4</td><td>Commit</td><td></td></tr></tbody></table><ul><li>T2时刻，SessionA已经完成了对两行数据的更新，但没有提交</li><li>T3时候，SessionB对id=1的行进行更新，由于Session A没有提交，其依然持有id=1上的写锁，与Session B要加的写锁互斥，所以SessionB被阻塞，直到Session A提交，释放锁，才能对执行更新语句</li></ul>]]></content:encoded>
      
      
      <category domain="http://www.gagahappy.com/categories/database/">数据库</category>
      
      
      <category domain="http://www.gagahappy.com/tags/mysql/">mysql</category>
      
      
    </item>
    
  </channel>
</rss>
