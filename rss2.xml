<?xml version="1.0" encoding="utf-8"?>
<rss version="2.0"
  xmlns:atom="http://www.w3.org/2005/Atom"
  xmlns:content="http://purl.org/rss/1.0/modules/content/">
  <channel>
    <title>睡月飞天膏药</title>
    <link>https://www.gagahappy.com/</link>
    
    <image>
      <url>https://www.gagahappy.com/icon.png</url>
      <title>睡月飞天膏药</title>
      <link>https://www.gagahappy.com/</link>
    </image>
    
    <atom:link href="https://www.gagahappy.com/rss2.xml" rel="self" type="application/rss+xml"/>
    
    <description>后端, 操作系统, 互联网, 程序开发, Linux, 数据库, MySql, Golang, Ruby</description>
    <pubDate>Sat, 05 Jun 2021 08:54:21 GMT</pubDate>
    <generator>http://hexo.io/</generator>
    
    <item>
      <title>Fmt对string中零值的处理</title>
      <link>https://www.gagahappy.com/go-fmt-string-with-zerovalue/</link>
      <guid>https://www.gagahappy.com/go-fmt-string-with-zerovalue/</guid>
      <pubDate>Sat, 05 Jun 2021 06:32:08 GMT</pubDate>
      
        
        
          
          
      <description>&lt;p&gt;&lt;code&gt;fmt&lt;/code&gt;格式化含有0值的&lt;code&gt;string&lt;/code&gt;时，是如何显示的&lt;/p&gt;
&lt;figure class=&quot;highlight go&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span</description>
          
        
      
      
      
      <content:encoded><![CDATA[<p><code>fmt</code>格式化含有0值的<code>string</code>时，是如何显示的</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">buf := <span class="built_in">make</span>([]<span class="keyword">byte</span>, <span class="number">10</span>)</span><br><span class="line">buf[<span class="number">8</span>] = <span class="string">&#x27;A&#x27;</span></span><br><span class="line"><span class="built_in">copy</span>(buf, []<span class="keyword">byte</span>(<span class="string">&quot;hello&quot;</span>))</span><br><span class="line">fmt.Printf(<span class="string">&quot;cap(%d),len(%d)\n&quot;</span>, <span class="built_in">cap</span>(buf), <span class="built_in">len</span>(buf))</span><br><span class="line">fmt.Println(<span class="string">&quot;buf:&quot;</span>, buf)</span><br><span class="line">fmt.Printf(<span class="string">&quot;buf:%q\n&quot;</span>, buf)</span><br><span class="line">fmt.Println(<span class="string">&quot;buf:&quot;</span>, <span class="keyword">string</span>(buf))</span><br><span class="line"></span><br><span class="line">str := <span class="keyword">string</span>(buf)</span><br><span class="line">str = str + <span class="string">&quot; world&quot;</span></span><br><span class="line">fmt.Println(<span class="built_in">len</span>(str)) <span class="comment">// =&gt; 16</span></span><br><span class="line">fmt.Println(str)      <span class="comment">// =&gt; helloA world</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* output</span></span><br><span class="line"><span class="comment">cap(10),len(10)</span></span><br><span class="line"><span class="comment">buf: [104 101 108 108 111 0 0 0 65 0]</span></span><br><span class="line"><span class="comment">buf:&quot;hello\x00\x00\x00A\x00&quot;</span></span><br><span class="line"><span class="comment">buf: helloA</span></span><br><span class="line"><span class="comment">16</span></span><br><span class="line"><span class="comment">helloA world</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><p>1. 使用<code>fmt</code>打印<code>string(buf)</code>虽然显示为<code>helloA</code>，看上去字符数变少了，只有6个(0值没有显示，其<code>ascii码</code>是不可打印码)，但底层数据没变，依然是<code>[104 101 108 108 111 0 0 0 65 0]</code></p><p>2. 格式化参数<code>%q</code>直接对0值进行了输出<code>hello\x00\x00\x00A\x00</code>，它打印了<code>string</code>中的每一个字节，包括不可打印的字节</p><p>3. <code>str + &quot; world&quot;</code>的长度为16，也证明了<code>str</code>中的0值没有被去除(10 + 6 = 16)</p><p>4.使用<code>fmt</code>查看数据”长什么样子”有时候是不准确的</p>]]></content:encoded>
      
      
      <category domain="https://www.gagahappy.com/categories/development/">后端</category>
      
      
      <category domain="https://www.gagahappy.com/tags/golang/">golang</category>
      
      
      <comments>https://www.gagahappy.com/go-fmt-string-with-zerovalue/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>io.Writer 接口</title>
      <link>https://www.gagahappy.com/go-io-writer/</link>
      <guid>https://www.gagahappy.com/go-io-writer/</guid>
      <pubDate>Fri, 04 Jun 2021 06:46:58 GMT</pubDate>
      
        
        
          
          
      <description>&lt;h1 id=&quot;io-Writer接口实现要求&quot;&gt;&lt;a href=&quot;#io-Writer接口实现要求&quot; class=&quot;headerlink&quot;</description>
          
        
      
      
      
      <content:encoded><![CDATA[<h1 id="io-Writer接口实现要求"><a href="#io-Writer接口实现要求" class="headerlink" title="io.Writer接口实现要求"></a><code>io.Writer</code>接口实现要求</h1><p>开始以为只是实现了<code>Write</code>方法就行，看了源码发现还有很多细节上的要求</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// src/io/io.go</span></span><br><span class="line"><span class="keyword">type</span> Writer <span class="keyword">interface</span> &#123;</span><br><span class="line">Write(p []<span class="keyword">byte</span>) (n <span class="keyword">int</span>, err error)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>1.要把 <code>p</code>写入实现类型的底层数据中</p><p>2.要返回实际写入的长度和在写入时遇到的错误，如果实际写入的长度小于<code>len(p)</code>，返回的<code>err</code>必须是非<code>nil</code>的</p><p>3. <code>p</code>不能在方法内部被修改，即使临时性的也不可以</p><p>4. 不能对<code>p</code>进行保存</p>]]></content:encoded>
      
      
      <category domain="https://www.gagahappy.com/categories/development/">后端</category>
      
      
      <category domain="https://www.gagahappy.com/tags/golang/">golang</category>
      
      
      <comments>https://www.gagahappy.com/go-io-writer/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>安装 Gitalk 评论系统</title>
      <link>https://www.gagahappy.com/gitalk-install/</link>
      <guid>https://www.gagahappy.com/gitalk-install/</guid>
      <pubDate>Tue, 01 Jun 2021 06:25:33 GMT</pubDate>
      
        
        
          
          
      <description>&lt;h1 id=&quot;申请GitHub应用&quot;&gt;&lt;a href=&quot;#申请GitHub应用&quot; class=&quot;headerlink&quot; title=&quot;申请GitHub应用&quot;&gt;&lt;/a&gt;申请GitHub应用&lt;/h1&gt;&lt;h2 id=&quot;1-注册一个新应用&quot;&gt;&lt;a href=&quot;#1-注册一个新应用&quot;</description>
          
        
      
      
      
      <content:encoded><![CDATA[<h1 id="申请GitHub应用"><a href="#申请GitHub应用" class="headerlink" title="申请GitHub应用"></a>申请GitHub应用</h1><h2 id="1-注册一个新应用"><a href="#1-注册一个新应用" class="headerlink" title="1.  注册一个新应用"></a>1.  注册一个新应用</h2><p><a href="https://github.com/settings/applications/new">https://github.com/settings/applications/new</a> 有三项内容必须填写</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Application name：这个随意填写</span><br><span class="line">Homepage URL：你的网站的URL地址，包含http部分。</span><br><span class="line">Authorization callback URL：你的网站的URL地址，包含http部分，和上面的 Homepage URL 一致就行</span><br></pre></td></tr></table></figure><h2 id="2-Homepage-URL与Authorization-callback-URL的填写"><a href="#2-Homepage-URL与Authorization-callback-URL的填写" class="headerlink" title="2. Homepage URL与Authorization callback URL的填写"></a>2. <code>Homepage URL</code>与<code>Authorization callback URL</code>的填写</h2><ol><li>如果你的网站是host在github上的，是通过github分配给你的网址进行访问的，直接填写github分配给你的网站就可以，类似 <code>yourgithub.github.io</code></li><li>如果你有自己的域名，但网站内容是host在github上的，是通过cname的方式访问的，那么这两项都填你的域名</li><li>如果你有自己的域名，也有自己的站点，那么这两项都填你的域名</li></ol><p>在调试阶段，可以把这两项设置为你的本地地址，这样方便测试，而不用一次又一次的部署网站，等测试好之后再统一部署。</p><h2 id="3-生成Client信息"><a href="#3-生成Client信息" class="headerlink" title="3. 生成Client信息"></a>3. 生成Client信息</h2><p>点击 “register application”完成注册，系统会生成<code>Client ID</code>和<code>Client secrets</code>(需要手动点一下旁边的按钮)</p><h1 id="配置Gitalk"><a href="#配置Gitalk" class="headerlink" title="配置Gitalk"></a>配置Gitalk</h1><h2 id="通过Next主题进行配置"><a href="#通过Next主题进行配置" class="headerlink" title="通过Next主题进行配置"></a>通过<code>Next</code>主题进行配置</h2><p>如果你的网点是用Hexo驱动，且主题是<code>Next</code>，这个主题已经为我们配置了gitalk，只需配置即可</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">gitalk:</span></span><br><span class="line">  <span class="attr">enable:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">github_id:</span> <span class="string">你的Github登录账号</span></span><br><span class="line">  <span class="attr">repo:</span> <span class="string">gitalk</span> <span class="string">你的</span> <span class="string">Github仓库的名称</span></span><br><span class="line">  <span class="attr">client_id:</span> <span class="string">上面刚刚申请的</span> <span class="string">Client</span> <span class="string">ID</span></span><br><span class="line">  <span class="attr">client_secret:</span> <span class="string">上面刚刚申请的</span> <span class="string">Client</span> <span class="string">Secret</span></span><br><span class="line">  <span class="attr">admin_user:</span> <span class="string">你的Github登录账号</span></span><br><span class="line">  <span class="attr">distraction_free_mode:</span> <span class="literal">false</span></span><br><span class="line">  <span class="attr">proxy:</span> <span class="string">https://cors-anywhere.azm.workers.dev/https://github.com/login/oauth/access_token</span></span><br><span class="line">  <span class="attr">language:</span></span><br></pre></td></tr></table></figure><h2 id="使用官网配置"><a href="#使用官网配置" class="headerlink" title="使用官网配置"></a>使用官网配置</h2><p>官网地址：<a href="https://github.com/gitalk/gitalk">https://github.com/gitalk/gitalk</a></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> gitalk = <span class="keyword">new</span> Gitalk(&#123;</span><br><span class="line">  clientID: <span class="string">&#x27;GitHub Application Client ID&#x27;</span>,</span><br><span class="line">  clientSecret: <span class="string">&#x27;GitHub Application Client Secret&#x27;</span>,</span><br><span class="line">  repo: <span class="string">&#x27;GitHub repo&#x27;</span>,      <span class="comment">// The repository of store comments,</span></span><br><span class="line">  owner: <span class="string">&#x27;GitHub repo owner&#x27;</span>,</span><br><span class="line">  admin: [<span class="string">&#x27;GitHub repo owner and collaborators, only these guys can initialize github issues&#x27;</span>],</span><br><span class="line">  id: location.pathname,      <span class="comment">// Ensure uniqueness and length less than 50</span></span><br><span class="line">  distractionFreeMode: <span class="literal">false</span>  <span class="comment">// Facebook-like distraction free mode</span></span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">gitalk.render(<span class="string">&#x27;gitalk-container&#x27;</span>)</span><br></pre></td></tr></table></figure><h2 id="参数说明"><a href="#参数说明" class="headerlink" title="参数说明"></a>参数说明</h2><p>注：官网配置的参数和Hexo主题Next的参数是通用的</p><ul><li><code>repo</code>: 要求填写你的Github仓库的名称，这个仓库可以是你的github上的任意一个，但必须是公开的。评论内容会以 <code>issue</code>的形式保存到仓库的<code>issues</code>中，所以建议为评论单独新建一个仓库</li><li><code>admin</code>: 指定了可以初始化文章评论的github用户，一般只填写你自己就可以了</li><li><code>id</code>: 文章的URL路径，不包括域名，这个路径要求必须是唯一的，且不能超过50个字符(如果超过了，可以使用md5等工具对路径进行摘要缩短长度即可)。每一扁文章的评论和这个路径相关联，所以即使域名不同，只要文章的URL一样，就会显示相关联的评论。在Next主题中是自动配置的Hexo主题Next的参数定义在<code>layout/_third-party/comments/gitalk.njk</code>中</li><li><code>distractionFreeMode</code>：是否是聚精会神模式，即评论框在写评论的时候，周围是否变成黑</li></ul><h1 id="遇到的坑"><a href="#遇到的坑" class="headerlink" title="遇到的坑"></a>遇到的坑</h1><p>1. Error: Not Found：一般是仓库名称没有正确设置，请依据上面的参数说明部分进行设置</p><p>2. Related Issues not found：未找到相关的issue进行评论，出现这种情况是因为文章评论还未初始化，只需要点击下面的按钮，登录 GitHub 账户即可</p><p>3. 评论区一直加载不上：配置中的<code>proxy</code>地址不正确或已经失效。官网默认地址是<code>https://cors-anywhere.azm.workers.dev/https://github.com/login/oauth/access_token</code>。如果你使用的是Next主题，请确保也是这个地址</p><p>4.  评论时是黑色的：设置<code>distractionFreeMode</code>为false</p>]]></content:encoded>
      
      
      <category domain="https://www.gagahappy.com/categories/software/">软件</category>
      
      
      <category domain="https://www.gagahappy.com/tags/git/">git</category>
      
      
      <comments>https://www.gagahappy.com/gitalk-install/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>Go 语言 buffer.truncate 分析</title>
      <link>https://www.gagahappy.com/bytes-buffer-truncate/</link>
      <guid>https://www.gagahappy.com/bytes-buffer-truncate/</guid>
      <pubDate>Sun, 30 May 2021 06:50:41 GMT</pubDate>
      
        
        
          
          
      <description>&lt;p&gt;对于Golang的初学者，&lt;code&gt;Truncate&lt;/code&gt;方法的行为使人迷惑，它不是从 &lt;code&gt;buffer&lt;/code&gt;的头部截取 &lt;code&gt;n</description>
          
        
      
      
      
      <content:encoded><![CDATA[<p>对于Golang的初学者，<code>Truncate</code>方法的行为使人迷惑，它不是从 <code>buffer</code>的头部截取 <code>n 个</code>字节，而是丢弃<code>除了前n个</code>未读取的字节之外的所有未读取的字节，也是就只保留已读取的字节和还没有读取的<code>前n个</code>字节。这种逻辑确实让人不太适应</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Truncate discards all but the first n unread bytes from the buffer</span></span><br><span class="line"><span class="comment">// but continues to use the same allocated storage.</span></span><br><span class="line"><span class="comment">// It panics if n is negative or greater than the length of the buffer.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(b *Buffer)</span> <span class="title">Truncate</span><span class="params">(n <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line"><span class="keyword">if</span> n == <span class="number">0</span> &#123;</span><br><span class="line">b.Reset()</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line">b.lastRead = opInvalid</span><br><span class="line"><span class="keyword">if</span> n &lt; <span class="number">0</span> || n &gt; b.Len() &#123;</span><br><span class="line"><span class="built_in">panic</span>(<span class="string">&quot;bytes.Buffer: truncation out of range&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line">b.buf = b.buf[:b.off+n]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从源码的注释中还可以看到，截取后使用原 <code>buffer</code>保存保留下来的节字，不再额外占用内存空间。同时 n 的大小不能超过未读取字节的长度(第10行)</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">truncate</span><span class="params">()</span></span> &#123;</span><br><span class="line">  <span class="keyword">var</span> buffer bytes.Buffer</span><br><span class="line">  str := <span class="string">&quot;Simple byte buffer for marshaling data.&quot;</span></span><br><span class="line">  buffer.WriteString(str)</span><br><span class="line">  p := <span class="built_in">make</span>([]<span class="keyword">byte</span>, <span class="number">8</span>)</span><br><span class="line">  buffer.Read(p) <span class="comment">// Simple b</span></span><br><span class="line">  fmt.Println(<span class="keyword">string</span>(p))</span><br><span class="line"></span><br><span class="line">  buffer.Truncate(<span class="number">10</span>)    <span class="comment">// 截断到前10个未读节字 Simple byte buffer</span></span><br><span class="line">  buffer.Read(p)         <span class="comment">// 读取8个字节</span></span><br><span class="line">  fmt.Println(<span class="keyword">string</span>(p)) <span class="comment">// yte buff</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><code>p := make([]byte, 8)</code>先读取了8个字节</li><li><code>buffer.Truncate(10) </code>再从没有读取的字节中取出10个，丢掉其余未读取的字节，把已读取的8个字节和取出的10个字节保存到 <code>buffer</code>中，此时buffer中的内容为<code>Simple byte buffer</code></li><li><code>buffer.Read(p) </code>再读取8个字节，注意：这里不是从 buffer 的头部读取，而是从未读取处开始读取，即从<code>y</code>开始读取</li></ul>]]></content:encoded>
      
      
      <category domain="https://www.gagahappy.com/categories/development/">后端</category>
      
      
      <category domain="https://www.gagahappy.com/tags/golang/">golang</category>
      
      
      <comments>https://www.gagahappy.com/bytes-buffer-truncate/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>Go语言结构体在内存中的布局</title>
      <link>https://www.gagahappy.com/layout-of-struct/</link>
      <guid>https://www.gagahappy.com/layout-of-struct/</guid>
      <pubDate>Mon, 24 May 2021 06:02:42 GMT</pubDate>
      
        
        
          
          
      <description>&lt;h1 id=&quot;一些基础知识&quot;&gt;&lt;a href=&quot;#一些基础知识&quot; class=&quot;headerlink&quot;</description>
          
        
      
      
      
      <content:encoded><![CDATA[<h1 id="一些基础知识"><a href="#一些基础知识" class="headerlink" title="一些基础知识"></a>一些基础知识</h1><ul><li>字节对齐</li><li>unsafe.Sizeof</li><li>unsafe.Offsetof</li><li>内存空洞</li></ul><h2 id="字节对齐"><a href="#字节对齐" class="headerlink" title="字节对齐"></a>字节对齐</h2><p>可以使计算机在加载和保存数据时，更加的有效率</p><p>通常情况下布尔和数字类型需要对齐到它们本身的大小（最多8个字节），其它的类型对齐到机器字大小</p><h2 id="unsafe-Sizeof"><a href="#unsafe-Sizeof" class="headerlink" title="unsafe.Sizeof"></a>unsafe.Sizeof</h2><p>返回操作数在内存中的字节大小，参数可以是任意类型的表，但不会对表达式进行求值(不求值也能知道大小，好神奇呀)</p><p>unsafe.Sizeof 返回的大小只包含数据结构中固定的部分。如果结构体含有指针字段，不包括针指向的内容。Go语言中非聚合类型通常有一个固定的大小，而聚合类型没有固定的大小，比如 结构体类型和数组类型</p><h2 id="unsafe-Offsetof"><a href="#unsafe-Offsetof" class="headerlink" title="unsafe.Offsetof"></a>unsafe.Offsetof</h2><p>函数的参数必须是一个字段 x.f，然后返回 f 字段相对于 x 起始地址的偏移量，包括可能的空洞</p><h2 id="内存空洞"><a href="#内存空洞" class="headerlink" title="内存空洞"></a>内存空洞</h2><p>一个聚合类型（结构体或数组）的大小至少是所有字段或元素大小的总和，或者更大。因为可能存在内存空洞，内存空洞是编译器自动添加的没有被使用的内存空间，用于保证后面每个字段或元素的地址相对于结构或数组的开始地址能够合理地对齐。内存空洞可能会存在一些随机数据，可能会对用unsafe包直接操作内存的处理产生影响</p><h1 id="结构体内存布局"><a href="#结构体内存布局" class="headerlink" title="结构体内存布局"></a>结构体内存布局</h1><p>设：机器字大小为8个字节</p><h2 id="产生的空洞"><a href="#产生的空洞" class="headerlink" title="产生的空洞"></a>产生的空洞</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> x <span class="keyword">struct</span> &#123;</span><br><span class="line">  a <span class="keyword">bool</span></span><br><span class="line">  b <span class="keyword">int16</span></span><br><span class="line">  c []<span class="keyword">int</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* output</span></span><br><span class="line"><span class="comment">Sizeof(x)   = 32  Alignof(x)   = 8</span></span><br><span class="line"><span class="comment">Sizeof(x.a) = 1   Alignof(x.a) = 1 Offsetof(x.a) = 0</span></span><br><span class="line"><span class="comment">Sizeof(x.b) = 2   Alignof(x.b) = 2 Offsetof(x.b) = 2</span></span><br><span class="line"><span class="comment">Sizeof(x.c) = 24  Alignof(x.c) = 8 Offsetof(x.c) = 8</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><ul><li><code>x</code> 占用内存大小为 32字节</li><li><code>x.c</code>字段是一个切片，占用24个字节(3个机器字)，<code>c.data, c.len, c.cap</code> 分别用 8个字节(1 个机器字)</li><li><code>x.a + x.b</code> 总共占用 3字节。用<code>x</code>的占用总字节数 <code>32 - (1 + 2 + 24) = 5</code>， 说明有5字节的内存空洞</li><li>由于<code>x.c</code>占用了3个机器字，所以空洞不是它产生的</li><li> <code>x.a + x.b = 3</code>字节，不满一个机器字(8字节)，所以a和b之间，b和c之间产生了总共5字节的空洞</li></ul><h2 id="字段偏移分析"><a href="#字段偏移分析" class="headerlink" title="字段偏移分析"></a>字段偏移分析</h2><ul><li><code>Offsetof(x.a) = 0</code> 说明 字段 a 处在结构的起始处，a与结构体起始处没有偏移(与起始处没有空洞)</li><li><code>Offsetof(x.b) = 2</code> 说明 字段 b 相对于结构体 起始处 偏移了 2 字节，而<code>Sizeof(x.a) = 1</code>说明 <code>x.a</code> 占用只占用了1字节，但 b 偏移了 2 字节，说明<code>b与a</code>之间有 1 字节的空洞，否则 b 只应该偏移 1 字节，即<code>x.a</code>的大小。</li><li>那么 a与b之间，总共是4字节的大小: <code>x.a</code> 1字节 + 空洞 1 字节 + <code>x.b</code> 2字节</li><li>如果 <code>x.c 与 x.b</code>之前没有空洞，则<code>x.c</code>只应该偏移4字节，但实际却偏移了8字节，则 说明 <code>x.c 与 x.b</code> 之间 存在 <code>8 - 4 = 4</code> 字节的空洞</li><li>所以 x 结构体的内存 分布是: x.a(1)____空洞(1)____x.b(2)____空洞(4)____x.c(24)</li><li>对齐方式：按一个机器字对齐的</li></ul><p><img src="http://img.gagahappy.cn/blog/2021/05/layout-of-struct.png_b1" alt="layout of struck" title="layout of struck"></p><h1 id="结构体字段顺序"><a href="#结构体字段顺序" class="headerlink" title="结构体字段顺序"></a>结构体字段顺序</h1><p>Go 语言中，结构内部字段的声明顺序和它们在内存中的顺序可能是不一样的。一个编译器可以随意地重新排列每个字段的内存位置，有效的包装可以使数据结构更加紧凑，从而节省内存空间</p><h2 id="内存占用"><a href="#内存占用" class="headerlink" title="内存占用"></a>内存占用</h2><p>不同结构体相同字段占用内存大小也会不一样，虽然 s1，s2，s3 有着相同的字段，但s1占用了较多的内存空间</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> s1 = <span class="keyword">struct</span> &#123;a <span class="keyword">bool</span>;b <span class="keyword">float64</span>;c <span class="keyword">int16</span>&#125;&#123;&#125; <span class="comment">// 3 words</span></span><br><span class="line"><span class="keyword">var</span> s2 = <span class="keyword">struct</span> &#123;a <span class="keyword">float64</span>;b <span class="keyword">int16</span>;c <span class="keyword">bool</span>&#125;&#123;&#125; <span class="comment">// 2 words</span></span><br><span class="line"><span class="keyword">var</span> s3 = <span class="keyword">struct</span> &#123;a <span class="keyword">bool</span>;b <span class="keyword">int16</span>;c <span class="keyword">float64</span>&#125;&#123;&#125; <span class="comment">// 2 words</span></span><br></pre></td></tr></table></figure><h2 id="s1占用空间"><a href="#s1占用空间" class="headerlink" title="s1占用空间"></a>s1占用空间</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">sizeof(s1) =   <span class="number">24</span> Alignof(s1) =    <span class="number">8</span></span><br><span class="line">Sizeof(s1.a) =  <span class="number">1</span> Alignof(s1.a) =  <span class="number">1</span> Offsetof(s1.a) =  <span class="number">0</span></span><br><span class="line">Sizeof(s1.b) =  <span class="number">8</span> Alignof(s1.b) =  <span class="number">8</span> Offsetof(s1.b) =  <span class="number">8</span></span><br><span class="line">Sizeof(s1.c) =  <span class="number">2</span> Alignof(s1.c) =  <span class="number">2</span> Offsetof(s1.c) =  <span class="number">16</span></span><br></pre></td></tr></table></figure><p>综上: <code>s1.a 与 s1.b</code> 之间有 7 字节 的空洞，<code>s1.c与结构体结束处</code>(尾部)有 6 字节的空洞</p><p>所以: s1 总字节数是 1 + 8 + 2 + (7 + 6) 空洞 = 24 <em>byte</em>，即3个机器字，可以看出 s1 的字段与字段之间，排列的并不是很紧凑，有较大空洞，造成了内存的浪费</p><p>对齐方式：按一个机器字对齐的</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">|-a-|----------holes------------| 8字节，即一个机器字</span><br><span class="line">|---------------b---------------| 8字节，即一个机器字</span><br><span class="line">|---c---|---------holes---------| 8字节，也可看出是按一个机器字对齐的</span><br></pre></td></tr></table></figure><h2 id="s2-占用空间"><a href="#s2-占用空间" class="headerlink" title="s2 占用空间"></a>s2 占用空间</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">sizeof(s2) =   <span class="number">16</span> Alignof(s2) =    <span class="number">8</span></span><br><span class="line">Sizeof(s2.a) =  <span class="number">8</span> Alignof(s2.a) =  <span class="number">8</span> Offsetof(s2.a) =  <span class="number">0</span></span><br><span class="line">Sizeof(s2.b) =  <span class="number">2</span> Alignof(s2.b) =  <span class="number">2</span> Offsetof(s2.b) =  <span class="number">8</span></span><br><span class="line">Sizeof(s2.c) =  <span class="number">1</span> Alignof(s2.c) =  <span class="number">1</span> Offsetof(s2.c) =  <span class="number">10</span></span><br></pre></td></tr></table></figure><p>综上: <code>s2.a</code> 的大小是一个机器字，本身就是对齐的，且是所有字段中长度最大的，与 <code>s2.b</code>之间没有空洞，<code>s2.c紧贴s2.b</code>，它们之间也没有空洞，<code>s2.c与结构体结束处</code>(尾部)有 5(8-2+1) 字节的空洞</p><p>所以: <code>s2</code> 总字节数是 <code>8 + 2 + 1 + (5) 空洞 = 16 byte</code>，即2个机器字，可以看出 s2 的字段与字段之间，排列是很紧凑，可以大大节省内存空间</p><p>对齐方式：按一个机器字对齐的</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">|---------------a---------------| 8字节，即一个机器字</span><br><span class="line">|---b---|-c-|-------holes-------| 8字节，即一个机器字</span><br></pre></td></tr></table></figure><h2 id="s3占用空间"><a href="#s3占用空间" class="headerlink" title="s3占用空间"></a>s3占用空间</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">sizeof(s3) =   <span class="number">16</span> Alignof(s3) =    <span class="number">8</span></span><br><span class="line">Sizeof(s3.a) =  <span class="number">1</span> Alignof(s3.a) =  <span class="number">1</span> Offsetof(s3.a) =  <span class="number">0</span></span><br><span class="line">Sizeof(s3.b) =  <span class="number">2</span> Alignof(s3.b) =  <span class="number">2</span> Offsetof(s3.b) =  <span class="number">2</span></span><br><span class="line">Sizeof(s3.c) =  <span class="number">8</span> Alignof(s3.c) =  <span class="number">8</span> Offsetof(s3.c) =  <span class="number">8</span></span><br></pre></td></tr></table></figure><p>对齐方式：按一个机器字对齐的</p><p>s3 布局与 s2 相似，可以看成是上下两层对调了，但排列是很紧凑的，也是2个机器字</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">|-a-|---b---|-------holes-------| 8字节，即一个机器字</span><br><span class="line">|---------------c---------------| 8字节，也可看出是按一个机器字对齐的</span><br></pre></td></tr></table></figure><h1 id="相关问题"><a href="#相关问题" class="headerlink" title="相关问题"></a>相关问题</h1><p>未来的Go语言编译器应该会默认优化结构体的顺序，当然应该也能够指定具体的内存布局，相同讨论请参考 <a href="https://github.com/golang/go/issues/10014">Issue10014</a></p>]]></content:encoded>
      
      
      <category domain="https://www.gagahappy.com/categories/development/">后端</category>
      
      
      <category domain="https://www.gagahappy.com/tags/golang/">golang</category>
      
      
      <comments>https://www.gagahappy.com/layout-of-struct/#disqus_thread</comments>
      
    </item>
    
  </channel>
</rss>
