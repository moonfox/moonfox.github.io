<?xml version="1.0" encoding="utf-8"?>
<rss version="2.0"
  xmlns:atom="http://www.w3.org/2005/Atom"
  xmlns:content="http://purl.org/rss/1.0/modules/content/">
  <channel>
    <title>漂自己的移，让别人都撞墙去吧</title>
    <link>https://www.gagahappy.com/</link>
    
    <image>
      <url>https://www.gagahappy.com/icon.png</url>
      <title>漂自己的移，让别人都撞墙去吧</title>
      <link>https://www.gagahappy.com/</link>
    </image>
    
    <atom:link href="https://www.gagahappy.com/rss2.xml" rel="self" type="application/rss+xml"/>
    
    <description>喜欢熬夜，喜欢畅游互联网，喜欢鼓捣Ubuntu，喜欢玩魔方臭显摆，喜欢小团体集体行动，喜欢餐前DQ，喜欢STARBUCKS，喜欢看着MM穿着凉快的衣服，喜欢YY~</description>
    <pubDate>Mon, 31 May 2021 06:16:16 GMT</pubDate>
    <generator>http://hexo.io/</generator>
    
    <item>
      <title>Go 语言 buffer.truncate 分析</title>
      <link>https://www.gagahappy.com/bytes-buffer-truncate/</link>
      <guid>https://www.gagahappy.com/bytes-buffer-truncate/</guid>
      <pubDate>Sun, 30 May 2021 06:50:41 GMT</pubDate>
      
        
        
          
          
      <description>&lt;p&gt;对于Golang的初学者，&lt;code&gt;Truncate&lt;/code&gt;方法的行为使人迷惑，它不是从 &lt;code&gt;buffer&lt;/code&gt;的头部截取 &lt;code&gt;n</description>
          
        
      
      
      
      <content:encoded><![CDATA[<p>对于Golang的初学者，<code>Truncate</code>方法的行为使人迷惑，它不是从 <code>buffer</code>的头部截取 <code>n 个</code>字节，而是丢弃<code>除了前n个</code>未读取的字节之外的所有未读取的字节，也是就只保留已读取的字节和还没有读取的<code>前n个</code>字节。这种逻辑确实让人不太适应</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Truncate discards all but the first n unread bytes from the buffer</span></span><br><span class="line"><span class="comment">// but continues to use the same allocated storage.</span></span><br><span class="line"><span class="comment">// It panics if n is negative or greater than the length of the buffer.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(b *Buffer)</span> <span class="title">Truncate</span><span class="params">(n <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line"><span class="keyword">if</span> n == <span class="number">0</span> &#123;</span><br><span class="line">b.Reset()</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line">b.lastRead = opInvalid</span><br><span class="line"><span class="keyword">if</span> n &lt; <span class="number">0</span> || n &gt; b.Len() &#123;</span><br><span class="line"><span class="built_in">panic</span>(<span class="string">&quot;bytes.Buffer: truncation out of range&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line">b.buf = b.buf[:b.off+n]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从源码的注释中还可以看到，截取后使用原 <code>buffer</code>保存保留下来的节字，不再额外占用内存空间。同时 n 的大小不能超过未读取字节的长度(第10行)</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">truncate</span><span class="params">()</span></span> &#123;</span><br><span class="line">  <span class="keyword">var</span> buffer bytes.Buffer</span><br><span class="line">  str := <span class="string">&quot;Simple byte buffer for marshaling data.&quot;</span></span><br><span class="line">  buffer.WriteString(str)</span><br><span class="line">  p := <span class="built_in">make</span>([]<span class="keyword">byte</span>, <span class="number">8</span>)</span><br><span class="line">  buffer.Read(p) <span class="comment">// Simple b</span></span><br><span class="line">  fmt.Println(<span class="keyword">string</span>(p))</span><br><span class="line"></span><br><span class="line">  buffer.Truncate(<span class="number">10</span>)    <span class="comment">// 截断到前10个未读节字 Simple byte buffer</span></span><br><span class="line">  buffer.Read(p)         <span class="comment">// 读取8个字节</span></span><br><span class="line">  fmt.Println(<span class="keyword">string</span>(p)) <span class="comment">// yte buff</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><code>p := make([]byte, 8)</code>先读取了8个字节</li><li><code>buffer.Truncate(10) </code>再从没有读取的字节中取出10个，丢掉其余未读取的字节，把已读取的8个字节和取出的10个字节保存到 <code>buffer</code>中，此时buffer中的内容为<code>Simple byte buffer</code></li><li><code>buffer.Read(p) </code>再读取8个字节，注意：这里不是从 buffer 的头部读取，而是从未读取处开始读取，即从<code>y</code>开始读取</li></ul>]]></content:encoded>
      
      
      <category domain="https://www.gagahappy.com/categories/development/">程序开发</category>
      
      
      <category domain="https://www.gagahappy.com/tags/golang/">golang</category>
      
      
    </item>
    
    <item>
      <title>Go语言结构体在内存中的布局</title>
      <link>https://www.gagahappy.com/layout-of-struct/</link>
      <guid>https://www.gagahappy.com/layout-of-struct/</guid>
      <pubDate>Mon, 24 May 2021 06:02:42 GMT</pubDate>
      
        
        
          
          
      <description>&lt;h1 id=&quot;一些基础知识&quot;&gt;&lt;a href=&quot;#一些基础知识&quot; class=&quot;headerlink&quot;</description>
          
        
      
      
      
      <content:encoded><![CDATA[<h1 id="一些基础知识"><a href="#一些基础知识" class="headerlink" title="一些基础知识"></a>一些基础知识</h1><ul><li>字节对齐</li><li>unsafe.Sizeof</li><li>unsafe.Offsetof</li><li>内存空洞</li></ul><h2 id="字节对齐"><a href="#字节对齐" class="headerlink" title="字节对齐"></a>字节对齐</h2><p>可以使计算机在加载和保存数据时，更加的有效率</p><p>通常情况下布尔和数字类型需要对齐到它们本身的大小（最多8个字节），其它的类型对齐到机器字大小</p><h2 id="unsafe-Sizeof"><a href="#unsafe-Sizeof" class="headerlink" title="unsafe.Sizeof"></a>unsafe.Sizeof</h2><p>返回操作数在内存中的字节大小，参数可以是任意类型的表，但不会对表达式进行求值(不求值也能知道大小，好神奇呀)</p><p>unsafe.Sizeof 返回的大小只包含数据结构中固定的部分。如果结构体含有指针字段，不包括针指向的内容。Go语言中非聚合类型通常有一个固定的大小，而聚合类型没有固定的大小，比如 结构体类型和数组类型</p><h2 id="unsafe-Offsetof"><a href="#unsafe-Offsetof" class="headerlink" title="unsafe.Offsetof"></a>unsafe.Offsetof</h2><p>函数的参数必须是一个字段 x.f，然后返回 f 字段相对于 x 起始地址的偏移量，包括可能的空洞</p><h2 id="内存空洞"><a href="#内存空洞" class="headerlink" title="内存空洞"></a>内存空洞</h2><p>一个聚合类型（结构体或数组）的大小至少是所有字段或元素大小的总和，或者更大。因为可能存在内存空洞，内存空洞是编译器自动添加的没有被使用的内存空间，用于保证后面每个字段或元素的地址相对于结构或数组的开始地址能够合理地对齐。内存空洞可能会存在一些随机数据，可能会对用unsafe包直接操作内存的处理产生影响</p><h1 id="结构体内存布局"><a href="#结构体内存布局" class="headerlink" title="结构体内存布局"></a>结构体内存布局</h1><p>设：机器字大小为8个字节</p><h2 id="产生的空洞"><a href="#产生的空洞" class="headerlink" title="产生的空洞"></a>产生的空洞</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> x <span class="keyword">struct</span> &#123;</span><br><span class="line">  a <span class="keyword">bool</span></span><br><span class="line">  b <span class="keyword">int16</span></span><br><span class="line">  c []<span class="keyword">int</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* output</span></span><br><span class="line"><span class="comment">Sizeof(x)   = 32  Alignof(x)   = 8</span></span><br><span class="line"><span class="comment">Sizeof(x.a) = 1   Alignof(x.a) = 1 Offsetof(x.a) = 0</span></span><br><span class="line"><span class="comment">Sizeof(x.b) = 2   Alignof(x.b) = 2 Offsetof(x.b) = 2</span></span><br><span class="line"><span class="comment">Sizeof(x.c) = 24  Alignof(x.c) = 8 Offsetof(x.c) = 8</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><ul><li><code>x</code> 占用内存大小为 32字节</li><li><code>x.c</code>字段是一个切片，占用24个字节(3个机器字)，<code>c.data, c.len, c.cap</code> 分别用 8个字节(1 个机器字)</li><li><code>x.a + x.b</code> 总共占用 3字节。用<code>x</code>的占用总字节数 <code>32 - (1 + 2 + 24) = 5</code>， 说明有5字节的内存空洞</li><li>由于<code>x.c</code>占用了3个机器字，所以空洞不是它产生的</li><li> <code>x.a + x.b = 3</code>字节，不满一个机器字(8字节)，所以a和b之间，b和c之间产生了总共5字节的空洞</li></ul><h2 id="字段偏移分析"><a href="#字段偏移分析" class="headerlink" title="字段偏移分析"></a>字段偏移分析</h2><ul><li><code>Offsetof(x.a) = 0</code> 说明 字段 a 处在结构的起始处，a与结构体起始处没有偏移(与起始处没有空洞)</li><li><code>Offsetof(x.b) = 2</code> 说明 字段 b 相对于结构体 起始处 偏移了 2 字节，而<code>Sizeof(x.a) = 1</code>说明 <code>x.a</code> 占用只占用了1字节，但 b 偏移了 2 字节，说明<code>b与a</code>之间有 1 字节的空洞，否则 b 只应该偏移 1 字节，即<code>x.a</code>的大小。</li><li>那么 a与b之间，总共是4字节的大小: <code>x.a</code> 1字节 + 空洞 1 字节 + <code>x.b</code> 2字节</li><li>如果 <code>x.c 与 x.b</code>之前没有空洞，则<code>x.c</code>只应该偏移4字节，但实际却偏移了8字节，则 说明 <code>x.c 与 x.b</code> 之间 存在 <code>8 - 4 = 4</code> 字节的空洞</li><li>所以 x 结构体的内存 分布是: x.a(1)____空洞(1)____x.b(2)____空洞(4)____x.c(24)</li><li>对齐方式：按一个机器字对齐的</li></ul><p><img src="http://img.gagahappy.cn/blog/2021/05/layout-of-struct.png_b1" alt="layout of struck" title="layout of struck"></p><h1 id="结构体字段顺序"><a href="#结构体字段顺序" class="headerlink" title="结构体字段顺序"></a>结构体字段顺序</h1><p>Go 语言中，结构内部字段的声明顺序和它们在内存中的顺序可能是不一样的。一个编译器可以随意地重新排列每个字段的内存位置，有效的包装可以使数据结构更加紧凑，从而节省内存空间</p><h2 id="内存占用"><a href="#内存占用" class="headerlink" title="内存占用"></a>内存占用</h2><p>不同结构体相同字段占用内存大小也会不一样，虽然 s1，s2，s3 有着相同的字段，但s1占用了较多的内存空间</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> s1 = <span class="keyword">struct</span> &#123;a <span class="keyword">bool</span>;b <span class="keyword">float64</span>;c <span class="keyword">int16</span>&#125;&#123;&#125; <span class="comment">// 3 words</span></span><br><span class="line"><span class="keyword">var</span> s2 = <span class="keyword">struct</span> &#123;a <span class="keyword">float64</span>;b <span class="keyword">int16</span>;c <span class="keyword">bool</span>&#125;&#123;&#125; <span class="comment">// 2 words</span></span><br><span class="line"><span class="keyword">var</span> s3 = <span class="keyword">struct</span> &#123;a <span class="keyword">bool</span>;b <span class="keyword">int16</span>;c <span class="keyword">float64</span>&#125;&#123;&#125; <span class="comment">// 2 words</span></span><br></pre></td></tr></table></figure><h2 id="s1占用空间"><a href="#s1占用空间" class="headerlink" title="s1占用空间"></a>s1占用空间</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">sizeof(s1) =   <span class="number">24</span> Alignof(s1) =    <span class="number">8</span></span><br><span class="line">Sizeof(s1.a) =  <span class="number">1</span> Alignof(s1.a) =  <span class="number">1</span> Offsetof(s1.a) =  <span class="number">0</span></span><br><span class="line">Sizeof(s1.b) =  <span class="number">8</span> Alignof(s1.b) =  <span class="number">8</span> Offsetof(s1.b) =  <span class="number">8</span></span><br><span class="line">Sizeof(s1.c) =  <span class="number">2</span> Alignof(s1.c) =  <span class="number">2</span> Offsetof(s1.c) =  <span class="number">16</span></span><br></pre></td></tr></table></figure><p>综上: <code>s1.a 与 s1.b</code> 之间有 7 字节 的空洞，<code>s1.c与结构体结束处</code>(尾部)有 6 字节的空洞</p><p>所以: s1 总字节数是 1 + 8 + 2 + (7 + 6) 空洞 = 24 <em>byte</em>，即3个机器字，可以看出 s1 的字段与字段之间，排列的并不是很紧凑，有较大空洞，造成了内存的浪费</p><p>对齐方式：按一个机器字对齐的</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">|-a-|----------holes------------| 8字节，即一个机器字</span><br><span class="line">|---------------b---------------| 8字节，即一个机器字</span><br><span class="line">|---c---|---------holes---------| 8字节，也可看出是按一个机器字对齐的</span><br></pre></td></tr></table></figure><h2 id="s2-占用空间"><a href="#s2-占用空间" class="headerlink" title="s2 占用空间"></a>s2 占用空间</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">sizeof(s2) =   <span class="number">16</span> Alignof(s2) =    <span class="number">8</span></span><br><span class="line">Sizeof(s2.a) =  <span class="number">8</span> Alignof(s2.a) =  <span class="number">8</span> Offsetof(s2.a) =  <span class="number">0</span></span><br><span class="line">Sizeof(s2.b) =  <span class="number">2</span> Alignof(s2.b) =  <span class="number">2</span> Offsetof(s2.b) =  <span class="number">8</span></span><br><span class="line">Sizeof(s2.c) =  <span class="number">1</span> Alignof(s2.c) =  <span class="number">1</span> Offsetof(s2.c) =  <span class="number">10</span></span><br></pre></td></tr></table></figure><p>综上: <code>s2.a</code> 的大小是一个机器字，本身就是对齐的，且是所有字段中长度最大的，与 <code>s2.b</code>之间没有空洞，<code>s2.c紧贴s2.b</code>，它们之间也没有空洞，<code>s2.c与结构体结束处</code>(尾部)有 5(8-2+1) 字节的空洞</p><p>所以: <code>s2</code> 总字节数是 <code>8 + 2 + 1 + (5) 空洞 = 16 byte</code>，即2个机器字，可以看出 s2 的字段与字段之间，排列是很紧凑，可以大大节省内存空间</p><p>对齐方式：按一个机器字对齐的</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">|---------------a---------------| 8字节，即一个机器字</span><br><span class="line">|---b---|-c-|-------holes-------| 8字节，即一个机器字</span><br></pre></td></tr></table></figure><h2 id="s3占用空间"><a href="#s3占用空间" class="headerlink" title="s3占用空间"></a>s3占用空间</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">sizeof(s3) =   <span class="number">16</span> Alignof(s3) =    <span class="number">8</span></span><br><span class="line">Sizeof(s3.a) =  <span class="number">1</span> Alignof(s3.a) =  <span class="number">1</span> Offsetof(s3.a) =  <span class="number">0</span></span><br><span class="line">Sizeof(s3.b) =  <span class="number">2</span> Alignof(s3.b) =  <span class="number">2</span> Offsetof(s3.b) =  <span class="number">2</span></span><br><span class="line">Sizeof(s3.c) =  <span class="number">8</span> Alignof(s3.c) =  <span class="number">8</span> Offsetof(s3.c) =  <span class="number">8</span></span><br></pre></td></tr></table></figure><p>对齐方式：按一个机器字对齐的</p><p>s3 布局与 s2 相似，可以看成是上下两层对调了，但排列是很紧凑的，也是2个机器字</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">|-a-|---b---|-------holes-------| 8字节，即一个机器字</span><br><span class="line">|---------------c---------------| 8字节，也可看出是按一个机器字对齐的</span><br></pre></td></tr></table></figure><h1 id="相关问题"><a href="#相关问题" class="headerlink" title="相关问题"></a>相关问题</h1><p>未来的Go语言编译器应该会默认优化结构体的顺序，当然应该也能够指定具体的内存布局，相同讨论请参考 <a href="https://github.com/golang/go/issues/10014">Issue10014</a> </p>]]></content:encoded>
      
      
      <category domain="https://www.gagahappy.com/categories/development/">程序开发</category>
      
      
      <category domain="https://www.gagahappy.com/tags/golang/">golang</category>
      
      
    </item>
    
    <item>
      <title>在动态值为 Nil 的接口上调用方法</title>
      <link>https://www.gagahappy.com/call-method-on-nil-of-interface-value/</link>
      <guid>https://www.gagahappy.com/call-method-on-nil-of-interface-value/</guid>
      <pubDate>Mon, 19 Apr 2021 07:37:54 GMT</pubDate>
      
        
        
          
          
      <description>&lt;h1 id=&quot;在动态值为-nil-的接口上调用方法&quot;&gt;&lt;a href=&quot;#在动态值为-nil-的接口上调用方法&quot; class=&quot;headerlink&quot; title=&quot;在动态值为 nil 的接口上调用方法&quot;&gt;&lt;/a&gt;在动态值为 nil</description>
          
        
      
      
      
      <content:encoded><![CDATA[<h1 id="在动态值为-nil-的接口上调用方法"><a href="#在动态值为-nil-的接口上调用方法" class="headerlink" title="在动态值为 nil 的接口上调用方法"></a>在动态值为 nil 的接口上调用方法</h1><p>把一个值为nil的某个实现类型的变量赋给了接口变量，是否可以在这个接口变量上调用该接口的方法</p><p>lib/lib.go</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> People <span class="keyword">struct</span> &#123;</span><br><span class="line">Name <span class="keyword">string</span></span><br><span class="line">Age  <span class="keyword">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Superman <span class="keyword">struct</span> &#123;</span><br><span class="line">People</span><br><span class="line">color <span class="keyword">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Mutant <span class="keyword">interface</span> &#123;</span><br><span class="line">Speaking()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Fly <span class="keyword">interface</span> &#123;</span><br><span class="line">Fly()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(sp Superman)</span> <span class="title">Speaking</span><span class="params">()</span></span> &#123;</span><br><span class="line">fmt.Printf(<span class="string">&quot;I&#x27;m %s&quot;</span>, sp.Name)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(sp *Superman)</span> <span class="title">Fly</span><span class="params">()</span></span> &#123;</span><br><span class="line">fmt.Println(<span class="string">&quot;I can fly&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>value.go</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">callMethodOnNil</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">var</span> mu lib.Mutant</span><br><span class="line"><span class="keyword">var</span> xman *lib.Superman</span><br><span class="line"></span><br><span class="line">fmt.Println(<span class="string">&quot;xman:&quot;</span>, xman) <span class="comment">// nil</span></span><br><span class="line">mu = xman</span><br><span class="line">fmt.Println(<span class="string">&quot;mu:&quot;</span>, mu) <span class="comment">// nil</span></span><br><span class="line"><span class="comment">// Panic: runtime error: invalid memory address or nil pointer dereference</span></span><br><span class="line"><span class="comment">// 动态类值为 nil 时，不能在其上调用值方法</span></span><br><span class="line"><span class="comment">// mu.Speaking()</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> fly lib.Fly</span><br><span class="line">fmt.Println(<span class="string">&quot;xman:&quot;</span>, xman) <span class="comment">// nil</span></span><br><span class="line">fly = xman</span><br><span class="line">fmt.Println(<span class="string">&quot;fly:&quot;</span>, fly) <span class="comment">// nil</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 动态类值为 nil 时，可以在其上调用指针方法</span></span><br><span class="line"><span class="comment">// Fly()方法可以被调用，它的接收者是 *T 类型，且方法中没有涉及到对类型属性的调用</span></span><br><span class="line">fly.Fly() <span class="comment">// I can fly</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h1><ol><li><p>值类型(T)的方法不能被调用，无论这个方法中是否涉及了对类型属性的调用</p></li><li><p>指针类型(*T)的方法可以被调用，但方法中不能涉及类型属性的调用</p></li></ol>]]></content:encoded>
      
      
      <category domain="https://www.gagahappy.com/categories/development/">程序开发</category>
      
      
      <category domain="https://www.gagahappy.com/tags/golang/">golang</category>
      
      
    </item>
    
    <item>
      <title>sync.Wait的使用</title>
      <link>https://www.gagahappy.com/go-sync-wait/</link>
      <guid>https://www.gagahappy.com/go-sync-wait/</guid>
      <pubDate>Wed, 14 Apr 2021 10:43:00 GMT</pubDate>
      
        
        
          
          
      <description>&lt;p&gt;如何让主 goroutine 在所有其他 goroutine 都运行完后，再退出&lt;/p&gt;
&lt;h1 id=&quot;sleep&quot;&gt;&lt;a href=&quot;#sleep&quot; class=&quot;headerlink&quot; title=&quot;sleep&quot;&gt;&lt;/a&gt;sleep&lt;/h1&gt;&lt;p&gt;通过 sleep</description>
          
        
      
      
      
      <content:encoded><![CDATA[<p>如何让主 goroutine 在所有其他 goroutine 都运行完后，再退出</p><h1 id="sleep"><a href="#sleep" class="headerlink" title="sleep"></a>sleep</h1><p>通过 sleep 让主 goroutine 在所有子goroutine运行结束后，再退出</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">usingSleep</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">10</span>; i++ &#123;</span><br><span class="line"><span class="keyword">go</span> fmt.Println(i)</span><br><span class="line">&#125;</span><br><span class="line">time.Sleep(time.Second)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>缺点：无法判断 for 循环到底需要多长时间，导致估计sleep的时间要么不够，要么太长</p><h1 id="缓冲通道"><a href="#缓冲通道" class="headerlink" title="缓冲通道"></a>缓冲通道</h1><p>通过缓冲通道让主 goroutine 在所有子goroutine运行结束后，再退出</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">usingChannel</span><span class="params">()</span></span> &#123;</span><br><span class="line">c := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;, <span class="number">10</span>)</span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">10</span>; i++ &#123;</span><br><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">(i <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">fmt.Println(i)</span><br><span class="line">c &lt;- <span class="keyword">struct</span>&#123;&#125;&#123;&#125;</span><br><span class="line">&#125;(i)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">10</span>; i++ &#123;</span><br><span class="line">&lt;-c</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>缺点：</p><ul><li>channel应该被用在goroutine间的通信</li><li>如果子goroutine太多，使用通道也会消耗很多资源</li></ul><h1 id="sync-WaitGroup"><a href="#sync-WaitGroup" class="headerlink" title="sync.WaitGroup"></a>sync.WaitGroup</h1><p>使用 sync.WaitGroup()控制主 goroutine 在所有子goroutine运行结束后，再退出</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">waitGroup</span><span class="params">()</span></span> &#123;</span><br><span class="line">wg := sync.WaitGroup&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">10</span>; i++ &#123;</span><br><span class="line">wg.Add(<span class="number">1</span>)</span><br><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">(i <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line"><span class="keyword">defer</span> wg.Done()</span><br><span class="line">fmt.Println(i)</span><br><span class="line">&#125;(i)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">wg.Wait() <span class="comment">// 一直阻塞主goroutine，直到wg为零</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// output</span></span><br><span class="line"><span class="comment">// 乱序输出,并不是按1,2,3,4...</span></span><br><span class="line"><span class="comment">// 2</span></span><br><span class="line"><span class="comment">// 4</span></span><br><span class="line"><span class="comment">// 7</span></span><br><span class="line"><span class="comment">// 3</span></span><br><span class="line"><span class="comment">// 1</span></span><br><span class="line"><span class="comment">// 0</span></span><br><span class="line"><span class="comment">// 9</span></span><br><span class="line"><span class="comment">// 5</span></span><br><span class="line"><span class="comment">// 8</span></span><br><span class="line"><span class="comment">// 6</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p>Wait() 方法的功能是，阻塞当前的 goroutine，直到其所属值中的计数器归零</p></li><li><p>不要把增加其计数器值的操作和调用其Wait方法的代码，放在不同的 goroutine 中执行，如果同时启用的两个 goroutine ，分别调用这两个方法(add 和 wait)，那么就有可能会让这里的Add方法抛出一个 panic。最好用“先统一Add，再并发Done，最后Wait”这种标准方式，来使用WaitGroup值</p></li><li><p>计数器不能为负值，发生为负的情况是：不适当地调用Done方法和Add方法都会如此。</p></li><li><p>Done()是Add(-1)的别名</p></li><li><p>计数不为0, 阻塞Wait()的运行</p></li></ul><h1 id="WaitGroup对象不是一个引用类型"><a href="#WaitGroup对象不是一个引用类型" class="headerlink" title="WaitGroup对象不是一个引用类型"></a>WaitGroup对象不是一个引用类型</h1><p>在通过函数传值的时候需要使用地址，不然会出现 <code>fatal error: all goroutines are asleep - deadlock!</code></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">passWGByPointer</span><span class="params">()</span></span> &#123;</span><br><span class="line">wg := sync.WaitGroup&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">10</span>; i++ &#123;</span><br><span class="line">wg.Add(<span class="number">1</span>)</span><br><span class="line"><span class="keyword">go</span> wgDone(i, &amp;wg)</span><br><span class="line">&#125;</span><br><span class="line">wg.Wait()</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">wgDone</span><span class="params">(i <span class="keyword">int</span>, wg *sync.WaitGroup)</span></span> &#123;</span><br><span class="line"><span class="keyword">defer</span> wg.Done()</span><br><span class="line">fmt.Println(i)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content:encoded>
      
      
      <category domain="https://www.gagahappy.com/categories/development/">程序开发</category>
      
      
      <category domain="https://www.gagahappy.com/tags/golang/">golang</category>
      
      
    </item>
    
    <item>
      <title>Git 使用 Rebase 代替 Merge</title>
      <link>https://www.gagahappy.com/using-rebase-instead-of-merge/</link>
      <guid>https://www.gagahappy.com/using-rebase-instead-of-merge/</guid>
      <pubDate>Tue, 06 Apr 2021 08:11:18 GMT</pubDate>
      
        
        
          
          
      <description>&lt;h1 id=&quot;合并还是变基&quot;&gt;&lt;a href=&quot;#合并还是变基&quot; class=&quot;headerlink&quot;</description>
          
        
      
      
      
      <content:encoded><![CDATA[<h1 id="合并还是变基"><a href="#合并还是变基" class="headerlink" title="合并还是变基"></a>合并还是变基</h1><p>合并分支时，应使用<code>rebase</code>合并分支而不是使用<code>merge</code></p><h2 id="merge"><a href="#merge" class="headerlink" title="merge"></a>merge</h2><p>在分支很多的时候，<code>merge</code>会使提交变得异常混乱，查找某个提交会非常不好找，即使使用图形工具，也无法快速的查找，如果想退到某次提交更是难上加难。<code>merge</code>即使删除了合并过来的分支，其合并轨迹也依然被保留，所以还是很乱。</p><p><img src="http://img.gagahappy.cn/blog/2021/04/using-rebase-instead-of-merge-merge.png_b1" alt="git merge" title="git merge"></p><h2 id="rebase"><a href="#rebase" class="headerlink" title="rebase"></a>rebase</h2><p>在分支很多的时候，不会产生很多的分支线，实践中应该就只有<code>master</code>,<code>release</code>等分支线，功能分支线在合并到<code>master</code> 上后都被删除，这样提交基本都在一条线上，十分清楚整洁。</p><p><img src="http://img.gagahappy.cn/blog/2021/04/using-rebase-instead-of-merge-rebase.png_b1" alt="git rebase" title="git rebase"></p><h1 id="使用rebase合并分支"><a href="#使用rebase合并分支" class="headerlink" title="使用rebase合并分支"></a>使用rebase合并分支</h1><h2 id="场景分析："><a href="#场景分析：" class="headerlink" title="场景分析："></a>场景分析：</h2><p>功能<code>feature1</code>与<code>feature2</code>都在开发，<code>feature1</code>先上线，合并到了master，此时，<code>feature2</code>不应使用<code>merge</code>对<code>master</code>进行合并操作，而是使用<code>rebase</code>进行合并</p><ul><li><p>master上的提交有：<code>[m1, m2, m3]</code></p></li><li><p>feature1上的提交有: <code>[f1_01, f1_02, f1_03]</code> </p></li><li><p>feature2上的提交有: <code>[f2_01, f2_02, f2_03]</code> </p></li></ul><p><code>feature1</code>先被合并到master: </p><ul><li>master上的提交有：<code>[m1, m2, m3, f1_01, f1_02, f1_03]</code></li></ul><p><code>feature2</code>合并master</p><ul><li><code>feature2</code>上的提交有：<code>[m1, m2, m3, f1_01, f1_02, f1_03，f2_01_new, f2_02_new, f2_03_new]</code></li></ul><h2 id="合并步骤"><a href="#合并步骤" class="headerlink" title="合并步骤"></a>合并步骤</h2><p><code>feature2</code>要把<code>master</code>上的提交合并过来，使用<code>rebase</code> 而不是<code>merge</code>，这样就会不产生合并提交，在向<code>master</code>提交时就变成了<code>快速向前</code></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">git co feature2</span><br><span class="line">git rebase master</span><br><span class="line"></span><br><span class="line"><span class="comment"># 如果发生冲突，解决冲突后把冲突文件加入 index 区</span></span><br><span class="line">git add -u </span><br><span class="line"><span class="comment"># 运行continue 以使rebase完成</span></span><br><span class="line">git rebase --<span class="built_in">continue</span></span><br></pre></td></tr></table></figure><ul><li><p>步骤1：<code>git rebase master</code>：以<code>master</code>分支做为<code>feature2</code>的基础</p></li><li><p>步骤2：计算出<code>feature2</code>与<code>master</code>上的差异提交，相当于<code>git log master...feture2</code>，即<code>[f2_01, f2_02, f2_03]</code> </p></li><li><p>步骤3：把<code>[f2_01, f2_02, f2_03]</code>在<code>master</code>上的最新提交<code>f1_03</code>上进行重放生成新的提交</p><p><code>[f2_01_new, f2_02_new, f2_03_new]</code></p><p>重放生成过程：</p><ol><li>f2_01以f1_03为基础，生成新的f2_01_new</li><li>f2_02以f2_01_new为基础，生成新的f2_02_new</li><li>f2_03以f2_02_new为基础，生成新的f2_03_new</li></ol></li><li><p>步骤4：把当前分支设置为<code>feature2</code></p><p>feature2<code>rebase</code>后的提交有<code>[m1, m2, m3, f1_01, f1_02, f1_03，f2_01_new, f2_02_new, f2_03_new]</code></p><p>之前的旧的<code>[f2_01, f2_02, f2_03]</code> 在<code>feature2</code>上就看不到了，但依然在git中，如果没有其它分支指向它们，则会被git 回收机制删除</p></li></ul><h1 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h1><ol><li>merge会让提交变得越来越混乱</li><li>rebase可以使主线一直保持清晰，rebase操作可以看是剪支操作，把分支剪下来，接到主线上。这样就可以把多条分支线变为一条，使所有提交变得清晰。</li><li>不要对已经<code>push</code>了的分支进行<code>rebase</code>，这会让已经存在的提交丢失，如果有人已经拉取了这个分支，也会给别人提交带来混乱</li></ol>]]></content:encoded>
      
      
      <category domain="https://www.gagahappy.com/categories/development/">程序开发</category>
      
      
      <category domain="https://www.gagahappy.com/tags/git/">git</category>
      
      
    </item>
    
  </channel>
</rss>
